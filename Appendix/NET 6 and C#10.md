# What’s new in .NET 6 and C# 10?

.NET 6 and C# 10 have brought many new features. We cannot visit them all, but we explore a selection of those features that are leveraged in the book or that I thought were worth mentioning.

In this section, we explore the following C# 10 features:

-   File-scoped namespaces
-   Global using directives
-   Implicit using directives
-   Constant interpolated strings
-   Record struct
-   Nullable reference types (added in C# 8 and enabled by default in .NET 6 templates)

On top of those features, we discussed the minimal hosting model already in Chapter 4 REST APIs.

## File-scoped namespaces

Declaring a file-scoped namespace reduces the horizontal indentation of our code files by removing the need to declare a block (`{}`). We previously wrote:

```csharp
namespace Vehicles
{
    public interface IVehicleFactory
    {
        // Omitted members
    }
}
```

We now can write:

```csharp
namespace Vehicles;
public interface IVehicleFactory
{
    // Omitted members
}
```

Saving four spaces at the beginning of each line may sound insignificant, but I feel it helps reduce the cognitive load by removing some indentation, and it gives us more screen space for meaningful code.

## Global using directives

Before .NET 6, there was always a long list of using directives at the top of each file. Global using directives allow us to define some using directives globally so those namespaces are automatically imported into every file of the project.

You can add global using directives in any project file, but I recommend centralizing them so they are not spread around the whole project. There are two places I feel they would fit:

1. In the `Program.cs` file because that’s the entry point of the program.
2. In a specific file named meaningfully like `GlobalUsings.cs`.

Here is an example that is comprised of three files:

```csharp
// GlobalUsings.cs
global using GlobalUsingDirectives.SomeCoolNamespace;

// SomeClass.cs
namespace GlobalUsingDirectives.SomeCoolNamespace;
public class SomeClass {  }

// Program.cs
Console.WriteLine(typeof(SomeClass).FullName);
```

When executing the program, we obtain the following output:

`GlobalUsingDirectives.SomeCoolNamespace.SomeClass`

Since there is no using directive in the `Program.cs` file, that proves the global using declared in the `GlobalUsings.cs` was used, and the whole thing worked as expected.

## Implicit using directives

To continue in the way of global using directives, the .NET team gave us a treat: implicit using directives. It is an opt-in feature that is enabled by default in .NET 6 templates by the following property (placed in a `PropertyGroup`) of your `.csproj` file:

```xml
<ImplicitUsings>enable</ImplicitUsings>
```

The imported namespaces are stored in an auto-generated `[project name].GlobalUsings.g.cs` file saved under the `obj/Debug/[version]` folder. The content varies depending on the project type. As of the time of writing, for console applications, the file contains the following code:

```csharp
// <auto-generated/>
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
```

With this enabled, we don’t have to bother with those redundant using directives. We can now write a Hello World program as a one-liner (OK, plus an eight-line csproj file). We can also register our own global using directives in our own files to complement this.

If you don’t like this, you can opt-out by deleting the `ImplicitUsings` property from your project file or by setting its value to disable.

## Constant interpolated strings

We do not use this feature in the book, but I felt it was worth mentioning. It happened a few times in my career that I needed this feature.

**Note**

As a workaround, I used static properties instead, but constants are replaced at build time and are equivalent to hardcoding their value, with a lower maintenance overhead (1 constant instead of hardcoded values in multiple places). Using constants is more performant than accessing a property.

Before .NET 6, we could not initialize a constant through interpolation. Now we can, as long as all the interpolated values are also string constants. Here is an example:

```csharp
const string DotNetVersion = "6";
const string BookTitle = $"An Atypical ASP.NET Core {DotNetVersion} Design Patterns Guide";
Console.WriteLine(BookTitle);
```

That code outputs the following:

`An Atypical ASP.NET Core 6 Design Patterns Guide`

That code has the same performance as the following:

```csharp
Console.WriteLine("An Atypical ASP.NET Core 6 Design Patterns Guide");
```

That’s it, a little more that we can do using C#.

## Record struct

This is another feature we do not use in the book but is worth mentioning. These are very similar to record classes but for structure types. As you can see from the following program, the syntax is very similar:

```csharp
var client1 = new MutableClient("John", "Doe");
client1.Firstname = "Jane";
Console.WriteLine(client1);

var client2 = new ImmutableClient("John", "Doe");
Console.WriteLine(client2);

public record struct MutableClient(string Firstname, string Lastname);
public readonly record struct ImmutableClient(string Firstname, string Lastname);
```

What is strange compared to record classes is that the positional properties of a record struct are mutable. To make positional properties immutable, we must use the `readonly record struct` keywords instead of `record struct`.

Executing the code outputs the following result:

`MutableClient { Firstname = Jane, Lastname = Doe }`
`ImmutableClient { Firstname = John, Lastname = Doe }`

You should apply the same decision process to record struct versus record class that you’d do to struct versus class. As a rule of thumb, when you are not sure if you should create a struct or a class, create a class (the same for record).

**Note**

Remember that structure types are passed by copy instead of by reference, so a copy occurs every time the struct “moves.”

## Nullable reference types

.NET 6 enables nullable reference type checking by default in templates. If you are migrating an existing project, you can enable this feature by adding the following property to your `csproj` file:

```xml
<Nullable>enable</Nullable>
```

That tells Visual Studio and the .NET compiler to run static code analyzers to detect possible null references. For example, the following code yields a few warnings (highlighted):

```csharp
var obj = Create(true);
Console.WriteLine($"Hello {obj.Name}!");

static MyClass? Create(bool shouldYieldANullResult)
{
    return shouldYieldANullResult
        ? default
        : new MyClass();
}

public class MyClass
{
    public string Name { get; set; }
}
```

The first warning is:

`CS8602 Dereference of a possibly null reference.`

Which informs us the return value of the Create method can be null (`MyClass?`). We could fix this by testing if `obj` is null or with the null-conditional operator (`?.`) like this:

```csharp
Console.WriteLine($"Hello {obj?.Name}!");
```

The second warning is:

`CS8618 Non-nullable property 'Name' must contain a non-null value when exiting constructor. Consider declaring the property as nullable.`

This message informs us that the `Name` property of the `MyClass` class can be null but was defined as not nullable (`string`). We can fix this one by marking the property as a nullable string instead like this:

```csharp
public class MyClass
{
    public string? Name { get; set; }
}
```

There are also many attributes available in the `System.Diagnostics.CodeAnalysis` namespace to deal with null references like `NotNull`, `NotNullWhen`, `MemberNotNull`, and `MemberNotNullWhen`.

Here is a good resource from Microsoft to help you get started with this titled "Learn techniques to resolve nullable warnings" ([https://adpg.link/Ljo8](https://adpg.link/Ljo8)).

The .NET team started to update the framework for a few versions before .NET 6, and the default is still just enabled in the template, so if you have a large codebase, you may want to address this iteratively.

Moreover, this feature relies on static analyzers, and the generated IL code is the same as before, so if external consumers call your code or if you call external consumers, runtime errors can still occur. In those cases, it is very important not to put blind confidence in this feature. It is a very good step forward and should help .NET developers write better code, but that’s it.

For example, writing a guard clause to make sure injected values are not null is still useful if the IoC container is not used (or maybe used by someone other than you), or another third-party container is set up in the project. If you rely solely on the .NET IoC container and the analyzers (null-state analysis), no external consumer exists, and you believe that’s safe enough for your project, you can avoid writing guard clauses. If you are writing libraries that consumers could use and have disabled null checks, I suggest writing some. Moreover, guards are pretty cheap to write, so they should not negatively impact the cost of the product you are working on. On the contrary, catching precise errors early can save you time and money.

### Forcing the compiler to think a variable is not null

It often happens that we must tell the compiler—and the analyzers—that certain part of the code is not null, so it stops complaining. We can use the `!` character for this. Here's an example from Chapter 17:

```csharp
// ...
var peppers = await db.Products.FindAsync(5);
Assert.NotNull(peppers);
Assert.Equal(0, peppers!.QuantityInStock);
```

The `!` in the preceding code tells the compiler that `peppers` is not null, which in this case is tested by the previous line (`Assert.NotNull(peppers);`).

We can also trick the compiler into initializing a property, like we did in Chapter 13:

```csharp
public record class ConcertRegistrationResult
{
    // ...
    public User User { get; init; } = null!;
    // ...
}
```

In this case, we could also use the `required` keyword, which forces us to initialize the property:

```csharp
public record class ConcertRegistrationResult
{
    // ...
    public required User User { get; init; }
    // ...
}
```
